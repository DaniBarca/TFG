Normalmente un motor gráfico incluye una serie de herramientas para facilitar el desarrollo, pero debido a las carencias de nuestro motor en este aspecto, he tenido que programarlas yo mismo. Este apéndice se presenta como referencia para los fragmentos de código que hacen uso de estas herramientas a lo largo de este documento, y como muestra del funcionamiento de estas.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Comparación de tipos imprecisos}
En la mayoría de dispositivos los números de coma flotante tienen un cierto nivel de imprecisión. Esto no suele ser un problema porque suelen tener mucha más precisión de la necesaria, y en su defecto hay otras formas de conseguir aún más precisión. El problema es no podemos comparar dichos números porque rara vez van a ser \textit{exactamente} idénticos. Para ello he creado las funciones:

\begin{lstlisting}
bool compare_float(float A, float B, float precission = 0.01f);
bool compare_vec(glm::vec3, glm::vec3, float precission = 0.01f);
\end{lstlisting}

La cual sencillamente compara que el valor absoluto de la diferencia entre los dos números sea inferor a la precisión requerida (por defecto $0.01$). Como los vectores en glm utilizan números de coma flotante, tenemos que hacer lo mismo para poder compararlos, pero esta vez comparando sus 3 componentes.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Proyección punto-rayo y punto-línea}
\label{sec:pointrayproj}
Entendiendo un rayo como un elemento formado por un punto y una dirección y una línea como un segmento de un rayo delimitado por dos puntos, he creado las siguientes dos funciones:

\begin{lstlisting}
float point_ray_projection(glm::vec3 ray_origin, glm::vec3 ray_direction, glm::vec3 point);
bool point_line_projection(glm::vec3 line_A, glm::vec3 line_B, glm::vec3 point, glm::vec3& result);
\end{lstlisting}

Su funcionamiento es muy similar, de hecho la segunda hace uso de la primera para obtener el resultado, pero tienen dos diferencias importantes: ``point\_ray\_projection" devuelve la distancia entre el origen del rayo y la proyección de nuestro punto, en la dirección especificada, mientras que ``point\_line\_projection" devuelve un booleano que indica si la proyección está dentro de nuestra línea, y asigna a la referencia ``result" el punto exacto de la proyección.

Hay diferentes situaciones en las que puede ser más útil una u otra: a veces querremos saber el punto exacto de la proyección, otras veces querremos saber la distancia de esta proyección respecto al punto de origen (sin necesidad de calcular el punto), y otras comprobar si esta proyección se encuentra delimitada entre dos puntos.

El cálculo de la proyección rayo-punto se basa en las propiedades del producto punto. A continuación explicaré el razonamiento por el cual sé que el producto punto puede usarse para calcular una proyección entre dos vectores:

El producto punto, o producto escalar de dos vectores, cumple la siguiente fórmula:
\[ dot(A,B) = |A||B|*cos(\Theta) \]

Donde $\theta$ es el ángulo que forman los dos vectores. Si asumimos que A es un vector normal (y nos aseguraremos de que así sea siempre), esto se reduce a:
\[ dot(|A|,B) = |B|*cos(\Theta) \]

Si miramos esta ecuación desde el punto de vista trigonométrico, $B$ puede entenderse como la hipotenusa del triángulo que forman $A$, $B$, y el vector de $B$ a la proyección de $B$ en $A$. El coseno, por definición, nos indica el ratio entre el lado contiguo de una esquina y la hipotenusa de un triángulo, por lo que al multiplicarlo por la magnitud de B obtenemos la longitud del lado contiguo, es decir, la distancia entre $A$ y la proyección de $B$.

Una vez calculada esta distancia, podemos sacar el punto de proyección fácilmente:
\[ P = origen + |direccion| * distancia \]

Todo esto se ha implementado de la siguiente manera:

\begin{lstlisting}
float Utils::point_ray_projection(
    glm::vec3 ray_origin, glm::vec3 ray_direction, glm::vec3 point
) {
	ray_direction = glm::normalize(ray_direction);
	return glm::dot(ray_direction, point - ray_origin);
}

bool Utils::point_line_projection(
    glm::vec3 A, glm::vec3 B, glm::vec3 point, glm::vec3 & result
) {
	glm::vec3 direction = glm::normalize(B - A);
	float projection = point_ray_projection(A, direction, point);
	result = A + direction * projection;
	float length = glm::length(B - A);
	return (
		(compare_float(projection, 0.0f) || projection > 0) && 
		(compare_float(projection, length) || projection < length)
	);
}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\section{Proyección punto-plano y punto-rectángulo}
\label{sec:pointplaneproj}
De un modo similar a lo que hemos visto en el apartado \ref{sec:pointrayproj}, podemos calcular la proyección a partir del producto punto.

Para ello debemos disponer de la normal de dicho plano. En el caso de la proyección punto-plano la requerimos como parámetro para definir el plano, pero en el caso de la proyección punto-rectángulo la calcularemos a partir de 3 puntos del plano. Este detalle es importante porque el orden de dichos puntos afectará a la dirección de la normal; no podemos hacer nada al respecto más que alertar a quien utilice esta función.

Dados 3 puntos $A$, $B$ y $C$, la normal del plano que forman es el producto vectorial de los vectores que van de un punto hacia los otros dos, normalizados, por ejemplo $N = AB \times AC$.

Teniendo esto en cuenta:
\begin{lstlisting}
glm::vec3 Utils::point_plane_projection(
    glm::vec3 origin, glm::vec3 normal, glm::vec3 point
) {
	normal = glm::normalize(normal);
	float dist = glm::dot(point - origin, normal);
	return point - normal * dist;
}

glm::vec3 Utils::point_rec_projection(
    glm::vec3 A, glm::vec3 B, glm::vec3 C, glm::vec3 point
) {
	glm::vec3 normal = glm::normalize(glm::cross(B - A, C - A));
	return  point_plane_projection(A, normal, point);
}
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Comprobar si cuatro puntos forman parte del mismo plano}
\label{sec:check4pointplane}
En un espacio de $D$ dimensiones, $D+1$ puntos forman parte del mismo espacio de $D-1$ dimensiones si el determinante de la matriz formada por las posiciones de los puntos organizadas verticalmente es 0 \footfullcite{points_sameplane}. En 3D:

\[
\begin{vmatrix}
& x_1 & x_2 & x_3 & x_4 &\\ 
& y_1 & y_2 & y_3 & y_4 &\\ 
& z_1 & z_2 & z_3 & z_4 &\\ 
& 1   & 1   & 1   & 1   &
\end{vmatrix} = 0
\]

Como glm ya dispone de una implementación para calcular el determinante de una matriz, ha bastado con generar la matriz a partir de los vectores y comprobar si su determinante es 0.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Comprobar si la proyección de un punto sobre un plano está dentro de un rectángulo}
Aunque es similar, este se diferencia del apartado \ref{sec:check4pointplane} en que no se requiere que el punto que queremos comparar esté en el mismo plano que el resto.

Para ello utilizamos la proyección punto-línea explicada en el apartado \ref{sec:pointrayproj}. Teniendo un rectángulo definido por 3 esquinas $A$, $B$, $C$, un punto $P$ está dentro del rectángulo si podemos proyectarlo satisfactoriamente sobre las líneas $AB$ y $AC$:

\begin{lstlisting}
bool Utils::in_rec(
    glm::vec3 A, glm::vec3 B, glm::vec3 C, glm::vec3 point
) {
	glm::vec3 proj1, proj2;
	return 
		point_line_projection(A, B, point, proj1) && 
		point_line_projection(A, C, point, proj2);
}
\end{lstlisting}
