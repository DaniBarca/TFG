\label{emscripten}
\section{Exportación a Web}
Uno de los puntos fuertes de nuestro planner es el poder ejecutarlo en web. El hecho de estar programado en C++, sin embargo, dificulta esta tarea. Teniendo cuenta una serie de consideraciones, es posible adaptar código C++ a web a través de Emscripten.

\subsection{Sobre Emscripten}
Emscripten es capaz de compilar código LLVM (Low Level Virtual Machine) a Javascript. LLVM es un lenguaje de código máquina que se puede generar compilando desde otros lenguajes, entre ellos C++. Dado que Emscripten compila desde LLVM (y no C++ directamente) realmente esto significa que podemos ejecutar código escrito en diversos lenguajes a través de Emscripten.

Emscripten\footfullcite{kripken_cppcon} nació como respuesta a la necesidad de escribir programas para web en lenguajes tradicionales de escritorio, con el objetivo de ganar velocidad, trabajar con un lenguaje familiar, y aprovechar las librerías existentes en dichos lenguajes. Hasta su aparición la única alternativa para poder hacer esto era el uso de plugins embebidos en el navegador, lo cual fracasó debido a la falta de estandarización y a la evolución de los propios navegadores, que cada vez más rechazan los plugins desde la popularización de las plataformas móviles.

Dada la extensión de funcionalidades de Javascript, para realizar el compilado se ha utilizado un subset de este, ``asm.js". Asm.js es un lenguaje intermedio que podemos ejecutar en navegadores; tiene una serie de restricciones con respecto a Javascript, como por ejemplo el hecho de ser un lenguaje tipado (aunque Javascript no lo es, en asm.js se comprueba el tipo de cada variable antes de trabajar con ella) o el requerimiento de trabajar sobre una única pila de memoria (un simple array de Javascript dentro del cual deben estar todos los datos que utilice el programa).

Si se aplica esta filosofía al código que programamos en C++, se puede entender fácilmente que dicha pila de memoria equivale a la memoria tal y como la ve un programa tradicional en C++. Es posible reservar memoria dentro de esta pila, y tener punteros a posiciones de la pila (que en realidad no son más que simples índices). Tiene un funcionamiento similar al Memory Pool descrito en el apartado \ref{engine_memory}.

Aunque en cuanto a eficiencia el código en asm.js en web está en torno al 50-67\% de su equivalente en escritorio, los resultados pueden ser sorprendentes pues asm.js es capaz de superar en velocidad a su equivalente escrito en Javascript tradicional. Al trabajar sobre datos estáticos y memoria pre-inicializada, el código resultante cuenta con una serie de optimizaciones que un programador no suele realizar manualmente.

Una de las actuales tendencias del web es la ejecución de código máquina, para lo cual está en fase de desarrollo la tecnología ``WebAssembly". Sin embargo, aún a día de hoy no está del todo claro cuando estará lista lo suficientemente avanzada\footfullcite{emscripten_ready}, por lo que el papel de asm.js es importante como paso intermedio, para que los desarrolladores puedan ir adoptando la tecnología antes de ser funcional del todo. Emscripten también tiene un rol muy importante en este proceso, porque es el encargado tanto de compilar a asm.js hoy como lo será de compilar a WebAssembly en el futuro\footfullcite{webasm_roadmap}.

Emscripten ya se está utilizando hoy en día en diversos proyectos de cierta categoría, especialmente en aplicaciones gráficas.

Es importante también tener en cuenta algunos de los defectos de utilizar Emscripten respecto a programar directamente en Javascript:

\begin{itemize}
    \item Es necesario saber desde el primer momento cuanta memoria se va a necesitar. Aunque superar dicha memoria no hará que el programa falle (Emscripten es capaz de reasignar memoria cuando se sobrepasa el límite), permitir que esto ocurra no es en absoluto recomendable, puesto que ralentizaría el programa.
    
    \item Se requiere un proceso de adaptación considerable: muchas de las cosas que el programador da por sentadas en C++ no se cumplen en Javascript. Como se puede ver a lo largo del capítulo \ref{emscripten}, no se puede inicializar el programa, gestionar los ficheros o ejecutar el bucle del programa del mismo modo en que se haría en C++.
    
    \item Se pierde poder de decisión sobre algunas de las tecnologías que se pueden querer utilizar porque simplemente no están disponibles, como versiones modernas de OpenGL o algunas operaciones SIMD. Esto cambiará en el futuro según avance la tecnología, pero a día de hoy es un limitante.
    
    \item Si se desea que el mismo código se pueda ejecutar en diversas plataformas, habrá otro proceso de adaptación considerable para hacer que el programa tenga en cuenta las consideraciones mencionadas según la plataforma. En realidad esto es más bien un defecto de la programación multi-plataforma que de Emscripten, pero se debe tener en cuenta que existirá un esfuerzo extra de desarrollo y un aumento de la complejidad del código.
    
    \item El debugging resulta sensiblemente más incómodo que con Javascript o C++ en escritorio\footfullcite{emscripten_debugging}. Normalmente para seguir los errores se hace uso de impresiones a través de la consola y el stack-trace que devuelve Emscripten cuando se produce un error (el cual no siempre es suficientemente descriptivo).
\end{itemize}

\subsection{Adaptación de la API gráfica}
\label{emscripten_gapi}
Como se ha podido ver en el apartado \ref{APIS}, el motor está pensado para funcionar utilizando la API gráfica Vulkan. El primer paso para hacer funcionar el programa con Emscripten ha sido utilizar una API gráfica que sea compatible con las tecnologías web.

WebGL está basado en OpenGL ES 2, y Emscripten puede reconocer las llamadas a esta segunda API y transformarlas en llamadas a WebGL. De modo que para hacer funcionar el motor ``bastará" con buscar los puntos donde se interactúe con la API de Vulkan y cambiarlos para que funcionen con OpenGL ES 2.

\textcolor{red}{(((AQUÍ FALTAN COSAS)))}

\subsection{Comunicación C++/Javascript}
\label{emscripten_comm}
Como es de esperar, es posible (necesario, de hecho) comunicar el código de Javascript con el código compilado desde C++\footfullcite{kripken_interacting}. En el desarrollo de la aplicación en C++ pueden definirse funciones pensadas para ser llamadas desde Javascript, y en el momento de compilar deben especificarse cuáles son esas funciones. Posteriormente, el Javascript resultante al compilar pone a disposición del desarrollador las funciones ``cwrap" i ``ccall".

La función ``cwrap" provee una función intermedia que se puede llamar como si de una función normal de Javascript se tratara. Esta función se encargará de llamar a su vez a la función de C++ correspondiente. En cambio, ``ccall" permite llamar directamente a la función de C++, pero como se explica a continuación es más verboso, por lo que si la función va a ser llamada varias veces puede ser más recomendable utilizar la primera alternativa.

Ambas opciones requieren que se especifique la firma de las funciones que van a ser llamadas. La firma de una función define el tipo de los parámetros que recibe y el tipo del valor de devuelve. De ahí que se diga que ``ccall" es más verboso: cada vez que se llame es necesario especificar la firma mientras que con ``cwrap" solo se debe hacer una vez.

Otro detalle importante a tener en cuenta es que no cualquier función puede ser llamada desde Javascript. Emscripten sólo permite que llamemos a funciones propias del lenguaje C, dado que C++ altera el nombre de las funciones al compilarlas (C++ permite a dos funciones llamarse igual si tienen firmas distintas, pero lo resuelve cambiando los nombres en el compilado resultante). Para garantizar que las funciones sean propias de C cuando programamos en C++ se utiliza el prefijo \texttt{extern "C"} antes de la definición.

Como se verá en el apartado \ref{init_emscripten} la comunicación entre C++ y Javascript es importante para controlar el flujo de la aplicación, pero también lo será para que desde el lado web se puedan crear interacciones que tengan efecto en el planificador. Con HTML y Javascript se pueden crear toda clase de eventos que pueden transmitirse a C++, como elementos de interfaz. Además, el planificador no controla los datos relacionados con el dominio de la aplicación, como por ejemplo qué muebles están disponibles en qué países; esta información se transmitirá a la aplicación a través de la web.

\subsection{Inicialización y bucle de ejecución}
\label{init_emscripten}
Uno de los inconvenientes de Emscripten es que Javascript ejecuta todos los procesos relacionados con la página en un único hilo de ejecución, incluyendo el renderizado, la gestión de eventos y la actualización de la propia página.

Javascript tiene una naturaleza orientada a eventos\footfullcite{javascript_queue}: dispone de una cola de eventos que se van añadiendo y ejecutando en un orden difícil de predecir. Entre esos eventos estará la propia ejecución del código Javascript y en consecuencia el código generado con Emscripten, pero también el resto de eventos mencionados que gestionan el comportamiento de la página. Si uno de los eventos tarda demasiado en terminar, bloqueará la cola de eventos y provocará que toda la página se bloquee.

Como el desarrollador no sabe en que orden se ejecutan los eventos, se dice que el lenguaje es asíncrono, y eso implica que se debe programar con cuidado para controlar que todo ocurra en el orden que se espera. La naturaleza asíncrona de Javascript puede confundir al programador haciéndole pensar que puede utilizar más de un hilo de ejecución (dado que en otros lenguajes la programación multi-hilo y la asincronía están estrechamente relacionadas); es importante tener presente que no es posible realizar dos tareas al mismo tiempo en este lenguaje. Sí se espera, en cambio, que WebAssembly pueda en el futuro ejecutar programas multi-hilo.

Como se menciona en el apartado \ref{emscripten_comm}, el flujo de la aplicación debe controlarse desde Javascript. El bucle de ejecución (\ref{fps_bucle_ejecucion}) es un bucle infinito, por lo que si lo ejecutamos estando dentro de C++ bloquearemos por completo la aplicación impidiendo que la cola avance. Por lo tanto el primer paso para hacer funcionar la aplicación pasa por hacer que las funciones ``Update" y ``Draw" del motor se llamen desde Javascript.

Para conseguirlo se debe utilizar la función ``setInterval"\footfullcite{setInterval}, que dado un intervalo de tiempo añade un evento para llamar a una función repetidamente. Especificando un intervalo de $1/6$ segundos, podemos hacer que la función de ``Update" se llame 60 veces por segundo. Es importante tener en cuenta que setInterval no garantiza que la función se llame realmente en el intervalo dado, sino que ese el mínimo de tiempo que se tardará en llamar; si la aplicación se ralentiza Javascript esperará a que termine la repetición anterior para llamar de nuevo. También el cálculo del tiempo entre frames (explicado en el apartado \ref{fps_bucle_ejecucion}) se hará desde Javascript aunque esto no es estrictamente necesario.

Antes de iniciar el bucle de ejecución se llamará a una función ``Init", con el objetivo de incializar el motor y el contexto de WebGL.

\subsection{Gestión de ficheros}
A lo largo de la ejecución del planificador será necesario proveer al software con una serie de assets (modelos 3D o texturas) y datos que provienen de ficheros. En C y C++ típicamente se accede al sistema de ficheros a través de la función ``fopen", que solicita al sistema operativo acceso a un fichero determinado; y después se extrae la información de este.

En C++, los datos del fichero que se quiere leer pasan a estar disponibles justo en el momento en que se piden, de forma síncrona; pero el proceso es mucho más complicado en Javascript. En Javascript no tenemos un sistema de ficheros, y si queremos tener acceso a alguno, debemos antes solicitarlo a un servidor remoto.

Es un problema porque las peticiones a servidores remotos se hacen de forma asíncrona (técnicamente se puede hacer de forma síncrona, pero se trata de una función obsoleta, que debe ser evitada y que tiene efectos secundarios como el bloqueo de la página); el hecho de que el funcionamiento sea diferente según la plataforma dificulta considerablemente el desarrollo.

Emscripten pone a disposición de los desarrolladores varias soluciones para facilitar el acceso a ficheros externos\footfullcite{emscripten_files}. Para que los cambios a realizar según la plataforma sean mínimos, Emscripten emula un sistema de ficheros de modo que podamos utilizarlo con ``fopen" igual que lo haríamos en C++. El modo en que esos ficheros pasen a estar disponibles en el sistema de ficheros, en cambio, puede variar:

\begin{itemize}
    \item Precarga sistema de ficheros: Los ficheros que se pre-carguen con este sistema, en el momento de compilar, se añadirán a un único archivo binario que se descarga al navegador junto al código generado. El sistema de archivos de Emscripten tiene una lista de estos ficheros con sus rutas y su posición en el archivo de precarga. Teniendo en cuenta que tanto los modelos 3D como las texturas son bastante pesados, y que en un planificador puede haber una gran cantidad, esto aumentaría considerablemente el peso de la descarga inicial, y el tiempo de carga; pero la ventaja es que los archivos pasan a estar disponibles de manera síncrona y sin cambiar en absoluto el código que los lee.
    \item Descarga síncrona: Emscripten provee la función ``emscripten\_wget", que dada la url de un archivo la descarga de forma síncrona a través del navegador. También se necesita dar un nombre al archivo cargado puesto que Emscripten lo guarda en el sistema de archivos virtual para que podamos acceder a él con ``fopen". Aunque con este método no sería necesario cambiar el flujo de la ejecución, como ya se ha mencionado este sistema es obsoleto.
    \item Descarga asíncrona: La alternativa asíncrona al anterior método es ``emscripten\_async\_wget". Del mismo modo que antes, esta función carga el archivo solicitado en el sistema de ficheros virtual, pero si intentamos leerlo justo después de llamar a la función la carga fallará, puesto que la carga aún no se ha realizado realmente. Para acceder al archivo debemos utilizar un puntero de función (o callback) que pasamos como parámetro a ``emscripten\_wget\_async", y que se llamará si el archivo se carga correctamente. También debemos pasarle otro callback que se llamará en caso de que la descarga fracase, y que nos permite gestionar tal evento. El callback de carga también recibe como parámetro los datos binarios del fichero solicitado, de modo que aunque seguimos pudiendo acceder a él desde el sistema de ficheros virtual con ``fopen", no es realmente necesario. Este sistema nos obliga a cambiar el flujo del programa, puesto que al no disponer aún del fichero solicitado, no podemos hacer nada que haga uso de este hasta que el callback de éxito se haya llamado.
\end{itemize}

La segunda opción ni siquiera será tenida en cuenta por sus características. Por un lado la primera alternativa obliga a descargar todos los assets desde el principio, y por otro la última no da acceso inmediato a los archivos como se suele presuponer cuando se programa en C++.

La solución pasa por utilizar una mezcla de ambas. Cuando se carga un modelo 3D o una textura, por la fuerza es necesario tener una respuesta inmediata, pero una vez se ha cargado un asset y se está utilizando, nada impide cambiar en un momento dado cambiar los datos de ese asset con un contenido diferente. Para tener acceso inmediato a los assets se pre-cargargan unos assets ``dummies", muy pequeños, que no supone ningún coste añadir junto con la carga de la app.

Cuando se quiera tener acceso a un asset, este se solicitará de forma asíncrona, pero inmediatamente después se proveerá al motor con un dummy, y se guardará el identificador para tener acceso al asset guardado. En el momento en que la carga asíncrona finalice, el asset dummy será sustituido por el correcto. Durante el tiempo intermedio se verá en pantalla un asset que no es el que debería verse, pero se trata de un tiempo generalmente muy corto y da un efecto de ``carga" al que los usuarios ya están bastante habituados.