\label{emscripten}
\section{Exportación a Web}
Uno de los puntos fuertes de nuestro planner es el poder ejecutarlo en web. El hecho de estar programado en C++, sin embargo, dificulta esta tarea. Teniendo cuenta una serie de consideraciones, es posible adaptar código C++ a web a través de Emscripten.

\subsection{Sobre Emscripten}
Emscripten es capaz de compilar código LLVM (Low Level Virtual Machine) a Javascript. LLVM es un lenguaje de código máquina que se puede generar compilando desde otros lenguajes, entre ellos C++. Dado que Emscripten compila desde LLVM (y no C++ directamente) realmente esto significa que podemos ejecutar código escrito en diversos lenguajes a través de Emscripten.

Emscripten\footfullcite{kripken_cppcon} nació como respuesta a la necesidad de escribir programas para web en lenguajes tradicionales de escritorio, con el objetivo de ganar velocidad, trabajar con un lenguaje familiar, y aprovechar las librerías existentes en dichos lenguajes. Hasta su aparición la única alternativa para poder hacer esto era el uso de plugins embebidos en el navegador, lo cual fracasó debido a la falta de estandarización y a la evolución de los propios navegadores, que cada vez más rechazan los plugins desde la popularización de las plataformas móviles.

Dada la extensión de funcionalidades de Javascript, para realizar el compilado se ha utilizado un subset de este, ``asm.js". Asm.js es un lenguaje intermedio que podemos ejecutar en navegadores; tiene una serie de restricciones con respecto a Javascript, como por ejemplo el hecho de ser un lenguaje tipado (aunque Javascript no lo es, en asm.js se comprueba el tipo de cada variable antes de trabajar con ella) o el requerimiento de trabajar sobre una única pila de memoria (un simple array de Javascript dentro del cual deben estar todos los datos que utilice el programa).

Si se aplica esta filosofía al código que programamos en C++, se puede entender fácilmente que dicha pila de memoria equivale a la memoria tal y como la ve un programa tradicional en C++. Es posible reservar memoria dentro de esta pila, y tener punteros a posiciones de la pila (que en realidad no son más que simples índices). Tiene un funcionamiento similar al Memory Pool descrito en el apartado \ref{engine_memory}.

Aunque en cuanto a eficiencia el código en asm.js en web está en torno al 50-67\% de su equivalente en escritorio, los resultados pueden ser sorprendentes pues asm.js es capaz de superar en velocidad a su equivalente escrito en Javascript tradicional. Al trabajar sobre datos estáticos y memoria pre-inicializada, el código resultante cuenta con una serie de optimizaciones que un programador no suele realizar manualmente.

Una de las actuales tendencias del web es la ejecución de código máquina, para lo cual está en fase de desarrollo la tecnología ``WebAssembly". Sin embargo, aún a día de hoy no está del todo claro cuando estará lista lo suficientemente avanzada\footfullcite{emscripten_ready}, por lo que el papel de asm.js es importante como paso intermedio, para que los desarrolladores puedan ir adoptando la tecnología antes de ser funcional del todo. Emscripten también tiene un rol muy importante en este proceso, porque es el encargado tanto de compilar a asm.js hoy como lo será de compilar a WebAssembly en el futuro\footfullcite{webasm_roadmap}.

Emscripten ya se está utilizando hoy en día en diversos proyectos de cierta categoría, especialmente en aplicaciones gráficas.

Es importante también tener en cuenta algunos de los defectos de utilizar Emscripten respecto a programar directamente en Javascript:

\begin{itemize}
    \item Es necesario saber desde el primer momento cuanta memoria se va a necesitar. Aunque superar dicha memoria no hará que el programa falle (Emscripten es capaz de reasignar memoria cuando se sobrepasa el límite), permitir que esto ocurra no es en absoluto recomendable, puesto que ralentizaría el programa.
    
    \item Se requiere un proceso de adaptación considerable: muchas de las cosas que el programador da por sentadas en C++ no se cumplen en Javascript. Como se verá a lo largo del capítulo \ref{emscripten}, no se puede inicializar el programa, gestionar los ficheros o ejecutar el bucle del programa del mismo modo en que se haría en C++.
    
    \item Se pierde poder de decisión sobre algunas de las tecnologías que se pueden querer utilizar porque simplemente no están disponibles, como versiones modernas de OpenGL o algunas operaciones SIMD. Esto cambiará en el futuro según avance la tecnología, pero a día de hoy es un limitante.
    
    \item Si se desea que el mismo código se pueda ejecutar en diversas plataformas, habrá otro proceso de adaptación considerable para hacer que el programa tenga en cuenta las consideraciones mencionadas según la plataforma. En realidad esto es más bien un defecto de la programación multi-plataforma que de Emscripten, pero se debe tener en cuenta que existirá un esfuerzo extra de desarrollo y un aumento de la complejidad del código.
    
    \item El debugging resulta sensiblemente más incómodo que con Javascript o C++ en escritorio\footfullcite{emscripten_debugging}. Normalmente para seguir los errores se hace uso de impresiones a través de la consola y el stack-trace que devuelve Emscripten cuando se produce un error (el cual no siempre es suficientemente descriptivo).
\end{itemize}

\subsection{Adaptación de la API gráfica}
Como se ha podido ver en el apartado \ref{APIS}, el motor está pensado para funcionar utilizando la API gráfica Vulkan. El primer paso para hacer funcionar el programa con Emscripten ha sido utilizar una API gráfica que sea compatible con las tecnologías web.

WebGL está basado en OpenGL ES 2, y Emscripten puede reconocer las llamadas a esta segunda API y transformarlas en llamadas a WebGL. De modo que para hacer funcionar el motor ``bastará" con buscar los puntos donde se interactúe con la API de Vulkan y cambiarlos para que funcionen con OpenGL ES 2.

\textcolor{red}{(((AQUÍ FALTAN COSAS, PETER)))}

\subsection{Comunicación C++/Javascript}
\label{emscripten_comm}
Como es de esperar, es posible comunicar el código de Javascript con el código compilado desde C++\footfullcite{kripken_interacting}. En el desarrollo de la aplicación en C++ pueden definirse funciones pensadas para ser llamadas desde Javascript, y en el momento de compilar deben especificarse cuáles son esas funciones. Posteriormente, el Javascript resultante al compilar pone a disposición del desarrollador las funciones ``cwrap" i ``ccall".

La función ``cwrap" provee una función intermedia que se puede llamar como si de una función normal de Javascript se tratara. Esta función se encargará de llamar a su vez a la función de C++ correspondiente. En cambio, ``ccall" permite llamar directamente a la función de C++, pero como se explica a continuación es más verboso, por lo que si la función va a ser llamada varias veces puede ser más recomendable utilizar la primera alternativa.

Ambas opciones requieren que se especifique la firma de las funciones que van a ser llamadas. La firma de una función define el tipo de los parámetros que recibe y el tipo del valor de devuelve. De ahí que se diga que ``ccall" es más verboso: cada vez que se llame es necesario especificar la firma mientras que con ``cwrap" solo se debe hacer una vez.

Otro detalle importante a tener en cuenta es que no cualquier función puede ser llamada desde Javascript. Emscripten sólo permite que llamemos a funciones propias del lenguaje C, dado que C++ altera el nombre de las funciones al compilarlas (C++ permite a dos funciones llamarse igual si tienen firmas distintas, pero lo resuelve cambiando los nombres en el compilado resultante). Para garantizar que las funciones sean propias de C cuando programamos en C++ se utiliza el prefijo \texttt{extern "C"} antes de la definición.

Como se verá en el apartado \ref{init_emscripten} la comunicación entre C++ y Javascript es importante para controlar el flujo de la aplicación, pero también lo será para que desde el lado web se puedan crear interacciones que tengan efecto en el planificador. Con HTML y Javascript se pueden crear toda clase de eventos que pueden transmitirse a C++, como elementos de interfaz. Además, el planificador no controla los datos relacionados con el dominio de la aplicación, como por ejemplo qué muebles están disponibles en qué países; esta información se transmitirá a la aplicación a través de la web.

\subsection{Inicialización y bucle de ejecución}
\label{init_emscripten}
Uno de los inconvenientes de Emscripten es que Javascript ejecuta todos los procesos relacionados con la página en un único hilo de ejecución, incluyendo el renderizado, la gestión de eventos y la actualización de la propia página.

Javascript tiene una naturaleza orientada a eventos\footfullcite{javascript_queue}: dispone de una cola de eventos que se van añadiendo y ejecutando en un orden difícil de predecir. Entre esos eventos estará la propia ejecución del código Javascript y en consecuencia el código generado con Emscripten, pero también el resto de eventos mencionados que gestionan el comportamiento de la página. Si uno de los eventos tarda demasiado en terminar, bloqueará la cola de eventos y provocará que toda la página se bloquee.

Como el desarrollador no sabe en que orden se ejecutan los eventos, se dice que el lenguaje es asíncrono, y eso implica que se debe programar con cuidado para controlar que todo ocurra en el orden que se espera. La naturaleza asíncrona de Javascript puede confundir al programador haciéndole pensar que puede utilizar más de un hilo de ejecución (dado que en otros lenguajes la programación multi-hilo y la asincronía están estrechamente relacionadas); es importante tener presente que no es posible realizar dos tareas al mismo tiempo en este lenguaje. Sí se espera, en cambio, que WebAssembly pueda en el futuro ejecutar programas multi-hilo.

Como se ha dicho en el apartado \ref{emscripten_comm}, el flujo de la aplicación debe controlarse desde Javascript. El bucle de ejecución (\ref{fps_bucle_ejecucion}) es un bucle infinito, por lo que si lo ejecutamos estando dentro de C++ bloquearemos por completo la aplicación impidiendo que la cola avance. Por lo tanto el primer paso para hacer funcionar la aplicación pasa por hacer que las funciones ``Update" y ``Draw" del motor se llamen desde Javascript.

Para conseguirlo se debe utilizar la función ``setInterval"\footfullcite{setInterval}, que dado un intervalo de tiempo añade un evento para llamar a una función repetidamente. Especificando un intervalo de $1/6$ segundos, podemos hacer que la función de ``Update" se llame 60 veces por segundo. Es importante tener en cuenta que setInterval no garantiza que la función se llame realmente en el intervalo dado, sino que ese el mínimo de tiempo que se tardará en llamar; si la aplicación se ralentiza Javascript esperará a que termine la repetición anterior para llamar de nuevo. También el cálculo del tiempo entre frames (explicado en el apartado \ref{fps_bucle_ejecucion}) se hará desde Javascript aunque esto no es estrictamente necesario.

Previamente a la llamada del bucle se llamará a una función ``Init", con el objetivo de incializar el motor y el contexto de WebGL

\subsection{Gestión de ficheros}
