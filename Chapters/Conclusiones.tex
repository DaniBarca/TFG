\section{Estado actual del desarrollo}
Para el desarrollo de la interfaz en la versión actual de la aplicación se ha hecho uso de la librería ImGui\footfullcite{imgui}. Se trata de una API que permite añadir diversos tipos de elementos de interfaz en la aplicación. Aunque es muy fácil de utilizar y versátil, probablemente será insuficiente de cara a la versión en producción de la aplicación: ImGui está altamente enfocado a interfaces de debugging y los requisitos estéticos de los planificadores no podrán cumplirse fácilmente. Será necesario buscar alternativas, por lo que de momento ImGui sólo se utiliza para debugging.

Una posible alternativa, al menos como paso intermedio antes de crear una interfaz más avanzada dentro del canvas 3D, es integrar la interfaz dentro del HTML. El buen funcionamiento de la aplicación en web hace que ya sea posible empezar a desarrollar la interfaz de usuario en HTML, utilizando la comunicación entre C++ y Javascript. Es una buena opción para empezar a trabajar en la interfaz sin interrumpir el desarrollo de la propia aplicación.

Al comenzar el desarrollo existía cierto escepticismo sobre las posibilidades de Emscripten. Llevar código de lenguajes de escritorio a plataformas web hasta hace poco ha sido algo muy poco común, a excepción de algunos plug-ins de navegador con muy poca recepción. Las primeras pruebas con Emscripten resultaron sorprendentes y eso fue un aliciente.

A pesar de ello, durante el desarrollo y la exportación del código con Emscripten han habido muchos problemas. Los más importantes han sido:

\begin{itemize}
    \item La compilación de código de C++ a Javascript es considerablemente lenta, hasta aproximadamente 5 minutos. En los momentos en los que han surgido dificultades específicas de Javascript o Emscripten esto ha ralentizado el desarrollo, puesto que se han necesitado varias iteraciones hasta dar con la combinación correcta de elementos. Aunque las interrupciones solo sean de 5 minutos la pérdida de tiempo productivo puede ser mucho mayor en muchos casos. Debido a esto la mayor parte del desarrollo se ha realizado debugando primero en escritorio, y no se ha empezado a probar en Emscripten hasta tener muy avanzado el código.

    \item Las diferencias entre la naturaleza síncrona de C++ y asíncrona de Javascript han generado dificultades. Las primeras aproximaciones para ejecutar el motor en web incluían el bucle de ejecución dentro del código C++, provocando el bloqueo de la aplicación. Esto ha afectado especialmente a la gestión de ficheros.

    \item La exportación del sistema de ficheros tiene un gran número de consideraciones a tener en cuenta. Aunque Emscripten ofrece herramientas muy efectivas para la carga de ficheros tanto síncrona como asíncrona, implementar dicha carga sin irrumpir demsiado en el comportamiento del motor gráfico ha sido difícil. El apartado \ref{emscripten_filesistem} sobre la implementación del sistema de ficheros en Emscripten es el resultado de varias iteraciones según surgían problemas inesperados. Por suerte, la posibilidad de cargar assets ``dummys" ha facilitado una solución al problema de la asincronía.
    
    \item La implementación del Patrón Comando, explicada en el apartado \ref{use_of_command} también es el resultado de varios intentos. El desconocimiento del patrón hizo que no se tuvieran en cuenta diversos detalles, como la necesidad de realizar acciones sin registrarlas en el historial o agrupar en un solo comando un conjunto de acciones cuando estas ocurren en tiempo real. La flexibilidad que ofrece la herencia de C++ hace que muchas soluciones puedan aplicarse directamente en los comandos, pero ello requiere conocer dichas soluciones por lo que la creación de comandos no está carente de cierta complejidad.
    
    \item La generación de mallas dinámicas ha tenido un gran número de detalles que no se habían tenido en cuenta al comenzar el desarrollo. El motor no estaba preparado para la actualización de mallas dinámicas y fue necesario añadir dicha funcionalidad, tanto en su versión de escritorio como en WebGL. El desarrollo se empezó sin disponer de dicha funcionalidad pero se pudo avanzar generando ficheros dinámicamente y leyéndolos al instante. Ha habido un gran número de pequeños bugs que han ralentizado el proceso. Se ha necesitado tener una gran cantidad de código antes de poder empezar a probarlo. Puede considerarse un acierto haber realizado el desarrollo de forma iterativa, puesto que no tenía sentido empezar a generar huecos dentro de las paredes sin tener funcionando una versión básica de estas.
    
    \item Ha habido pequeñas diferencias entre la API de OpenGL ES 2 y WebGL que han sido difíciles de solucionar. Un ejemplo es que OpenGL ES 2 permite asignar a un mismo buffer dos targets diferentes, lo cual fue un error en el código pero no hacía fallar la aplicación, mientras que en WebGL sí. En este punto se han unido varios factores como la falta de conocimiento sobre la API, la dificultad de debugar Emscripten, la poca cantidad de gente que se ha encontrado con problemas similres en Internet (el uso de Emscripten aún no está muy extendido) y la extensión del código del motor gráfico, que hace difícil encontrar los puntos específicos donde se produce un error.
\end{itemize}

Tras esta experiencia no se puede afirmar categóricamente que Emscripten sea la mejor alternativa para todas las situaciones, hay que recordar que Javascript también puede trasladarse a otras plataformas; pero Emscripten ha demostrado ser perfectamente capaz de trasladar código C++ a Javascript, y ejecutarlo con la misma estabilidad y una eficiencia muy similar.

Aunque la interfaz de usuario deja mucho que desear, el código es capaz de añadir, mover y eliminar paredes así como añadir, mover y eliminar huecos en estas. Todas las acciones pueden deshacerse y rehacerse, lo cual es una característica que nunca había existido en ninguna aplicación de la empresa.

Ha sido muy satisfactorio ver los buenos resultados de realizar un diseño preliminar, incluyendo la decisión de utilizar patrones. El código ha ganado calidad y mantenibilidad gracias a ello.

Por otro lado, el código tiene margen de mejora en cuanto a los gestores y generadores de entidades, explicados en el apartado \ref{managers}. Muchas de las buenas ideas introducidas en este apartado (como el uso de identificadores para que no se manipulen los datos desde fuera) se han incorporado a mitad del desarrollo y con bastante prisa. El resultado es que en su estado actual, mantener este fragmento de código requiere entender muy bien lo que hace. No debería ser difícil sin embargo, una vez conocidos los problemas y sus soluciones, mejorar este fragmento, pues está muy aislado del resto del código.

El hecho de ser un proyecto en empresa ha aportado ventajas y desventajas al desarrollo. Por un lado es difícil coordinar las prioridades de desarrollo con las prioridades del departamento de ventas. Ha habido mucha presión para tener resultados rápidamente a menudo en detrimento de la calidad del código. Existe una cierta deuda técnica en el código que pasará factura en el futuro. Por contra, trabajar en una empresa ha hecho contar con el apoyo de compañeros con muchos conocimientos sobre la materia. El motor gráfico es propio de la empresa y no se puede buscar información sobre este en Internet pero no solo se ha contado con ayuda para el desarrollo sino que incluso se ha podido adaptar el propio motor a las necesidades que han surgido. El hecho de tratarse de un proyecto real que será utilizado por una gran empresa eventualmente es un gran componente motivador, además del aliciente económico y la presión, aunque a priori no es una experiencia agradable, ayuda a no dormirse. Tener un horario estable de ocho horas diarias ha hecho que los avances fueran constantes y estables.

Habría sido deseable que más personas participaran directamente en el desarrollo de la aplicación. En un principio el equipo iba a estar formado por 3 personas además del equipo que programa el motor. Al final la presión de otros proyectos de la empresa ha hecho que solo hubiera un programador de en la mayor parte del desarrollo y eso ha afectado negativamente las previsiones iniciales.

Estos inconvenientes sin embargo han ido acompañados de comprensión por parte de la empresa, y una readaptación de las expectativas. En términos globales puede decirse que el balance de trabajar en un proyecto de empresa es más que positivo.

\section{Futuras iteraciones}
La adición de elementos interiores e interacción con estos no está terminada, aunque ya se sabe cómo se van a organizar estos elementos (véase el apartado \ref{managers}). Tampoco está hecha la interfaz de usuario y los inputs deben pulirse. Estas serán las prioridades en el futuro inmediato.

A más largo plazo, se deben implementar las diferentes aplicaciones que van a hacer uso del planificador. Se requerirá hacer aplicaciones con múltiples habitaciones y elementos estructurales como posiblemente zonas exteriores (balcones, terrazas o jardines). El planteamiento de diseñar el planificador para ser genérico hará que esto se pueda hacer con relativamente poco esfuerzo. Teniendo en cuenta que la empresa trabaja con diferentes aplicaciones en ambientes muy diferentes, hacer una aplicación genérica ha sido un acierto de cara al futuro.

Es probable que, una vez conocidos los problemas que se han encontrado a lo largo del desarrollo, se de otra iteración a algunos fragmentos del código, para mejorar la eficiencia y la estructura del propio código. Estos fragmentos se han desarrollado con prisa y asumiendo una cierta deuda técnica. Sin embargo, el diseño modular de la aplicación hace que sea posible realizar estas iteraciones trabajando con fragmentos aislados de código.

En su conjunto, la mantenibilidad del código es bastante buena y deberían poder incorporarse nuevos desarrolladores sin excesivo esfuerzo. Algunos fragmentos de código, en cambio, requieren un conocimiento más profundo del problema y de los elementos que intervienen en la solución. Un desarrollador descuidado podría llegar a tener problemas con dichos fragmentos por lo que existe margen de mejora en este aspecto.